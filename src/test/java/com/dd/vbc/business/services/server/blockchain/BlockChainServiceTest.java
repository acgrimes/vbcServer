package com.dd.vbc.business.services.server.blockchain;import com.dd.vbc.dao.blockChain.MerkleTreeDao;import com.dd.vbc.dao.blockChain.VoterTokenBlockMapDao;import com.dd.vbc.dao.blockChain.VotingTxBlockDao;import com.dd.vbc.db.mongo.MongoConfig;import com.dd.vbc.domain.*;import com.dd.vbc.messageService.request.ElectionRequest;import com.dd.vbc.utils.*;import org.apache.commons.lang3.SerializationUtils;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestInstance;import org.mockito.Mockito;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.mock.mockito.SpyBean;import reactor.core.publisher.Mono;import java.util.UUID;import java.util.concurrent.atomic.AtomicLong;import static org.junit.jupiter.api.Assertions.assertEquals;@SpringBootTest(classes = {BlockChainService.class,                            MerkleTreeDao.class,                            VotingTxBlockDao.class,                            VoterTokenBlockMapDao.class,                            MongoConfig.class})@TestInstance(TestInstance.Lifecycle.PER_CLASS)public class BlockChainServiceTest {    private static final Logger log = LoggerFactory.getLogger(BlockChainServiceTest.class);    @SpyBean    private BlockChainService blockChainService;    @Autowired    private VotingTxBlockDao votingTxBlockDao;    @Autowired    private MerkleTreeDao merkleTreeDao;    @Autowired    private VoterTokenBlockMapDao voterTokenBlockMapDao;    @BeforeAll    public void setupStaticVariables() {        ConsensusState.initializeServerList();        ConsensusState.initializeProxyServer();        ConsensusState.getServerList().stream().                forEach(serv -> {                    if(serv.getId().equals("A")) {                        ConsensusServer.setId(serv.getId());                        ConsensusServer.setHost(serv.getHost());                        ConsensusServer.setHttpPort(serv.getHttpPort());                        ConsensusServer.setReactivePort(serv.getReactivePort());                        ConsensusServer.setState(serv.getState());                    }                });        log.info("Server Id is: "+ConsensusServer.getId());        //TODO: these values need to be read from database.        ConsensusState.setCurrentIndex(new AtomicLong(1L));        ConsensusState.setCurrentTerm(new AtomicLong(1L));        //TODO: these values need to be read from database:        BlockChainMetadata.setActiveBlock(new AtomicLong(1L));        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(0L));        BlockChainMetadata.setBlockChainHash(SerializationUtils.serialize(UUID.randomUUID()));    }    @Test    public void createNewTxBlockTest() {        try {            ElectionRequest electionRequest = BuildElectionRequest.build();            AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                    BlockChainMetadata.getActiveBlock().get(),                    BlockChainMetadata.getActiveBlockTxCount().get(),                    electionRequest.getElectionTransaction());            appendEntry.setvToken(electionRequest.getVoter().getVtoken());            Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);            blockChainService.followerCommitEntryResponse(appendEntry);            byte[] hash = electionRequest.getElectionTransaction();            BlockChainMetadata.setBlockChainHash(hash);            String hashStr = BinaryHexConverter.bytesToHex(hash);            VotingTxBlock votingTxBlock = blockChainService.createNewTxBlock(hash).block();            VotingTxBlock vtb = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assertEquals(votingTxBlock.getBlockId(), vtb.getBlockId());            assertEquals(1L, vtb.getVotingBlockHeader().getTxCount(), "vtb.getBlockId() = " + vtb.getVotingBlockHeader().getTxCount());            String vtbHashStr = BinaryHexConverter.bytesToHex(vtb.getVotingBlockHeader().getPreviousBlockHash());            assertEquals(hashStr, vtbHashStr);            votingTxBlockDao.delete(vtb).block();        } catch (Exception ex) {            ex.printStackTrace();        }    }    @Test    public void updateTxBlockTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        String currentHashStr = BinaryHexConverter.bytesToHex(currentHash);        ElectionRequest electionRequest = BuildElectionRequest.build();        BlockChainMetadata.setBlockChainHash(currentHash);        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);        blockChainService.followerCommitEntryResponse(appendEntry);        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                                                               BlockChainMetadata.getActiveBlockTxCount().get(),                                                               currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        VotingTxBlock before = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();        assertEquals(BlockChainMetadata.getActiveBlock().get(), before.getBlockId());        assertEquals(votingTxBlock.getVotingBlockHeader().getDateTime(), before.getVotingBlockHeader().getDateTime());        assertEquals(currentHashStr, BinaryHexConverter.bytesToHex(before.getVotingBlockHeader().getPreviousBlockHash()));        blockChainService.updateTxBlock(votingTxBlock, electionRequest.getElectionTransaction()).block();        VotingTxBlock after = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();        assertEquals(BlockChainMetadata.getActiveBlock().get(), after.getBlockId());        assertEquals(votingTxBlock.getVotingBlockHeader().getDateTime(), after.getVotingBlockHeader().getDateTime());        assertEquals(currentHashStr, BinaryHexConverter.bytesToHex(after.getVotingBlockHeader().getPreviousBlockHash()));        votingTxBlockDao.delete(after).block();    }    @Test    public void generateMerkleTreeTest() {        try {            byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());            ElectionRequest electionRequest = BuildElectionRequest.build();            AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                    BlockChainMetadata.getActiveBlock().get(),                    BlockChainMetadata.getActiveBlockTxCount().get(),                    electionRequest.getElectionTransaction());            appendEntry.setvToken(electionRequest.getVoter().getVtoken());            Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);            blockChainService.followerCommitEntryResponse(appendEntry);            BlockChainMetadata.setBlockChainHash(currentHash);            BlockChainMetadata.setActiveBlock(new AtomicLong(21L));            BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(7L));            MerkleTree merkleTree = BuildMerkleTree.build(BlockChainMetadata.getActiveBlock().get(),                                                          BlockChainMetadata.getActiveBlockTxCount().get()-1L,                                                          currentHash);            MerkleTree insertedMerkleTree = merkleTreeDao.save(merkleTree).block();            assertEquals(21l, insertedMerkleTree.getBlockId(), "before merkleTree update block id is 21");            assertEquals(6L, insertedMerkleTree.getTxCount(), "before update to merkleTree tx count is 6");            assertEquals(6L, insertedMerkleTree.getNodeMap().entrySet().size(), "before update merkleTree nodes should be 6");            MerkleTree aMerkleTree = blockChainService.generateMerkleTree(appendEntry).block();            MerkleTree merkleTreeFound = merkleTreeDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assertEquals(21l, merkleTreeFound.getBlockId(), "after update BlockId should be 21");            assertEquals(7L, merkleTreeFound.getTxCount(), "after update Tx Count should be 7");            assertEquals(7L, merkleTreeFound.getNodeMap().entrySet().size(), "after update merkleTree nodes should be 7");            merkleTreeDao.delete(aMerkleTree).block();        } catch(Exception ex) {            ex.printStackTrace();        }    }    @Test    public void generateMerkleTreeNewMerkleTreeTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        String currentHashStr = BinaryHexConverter.bytesToHex(currentHash);        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);        blockChainService.followerCommitEntryResponse(appendEntry);        BlockChainMetadata.setBlockChainHash(currentHash);        BlockChainMetadata.setActiveBlock(new AtomicLong(210L));        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(1L));        MerkleTree merkleTree = blockChainService.generateMerkleTree(appendEntry).block();        MerkleTree aMerkleTree = merkleTreeDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();        assertEquals(210l, aMerkleTree.getBlockId(), "after update BlockId should be 210");        assertEquals(1L, aMerkleTree.getTxCount(), "after update Tx Count should be 1");        assertEquals(1L, aMerkleTree.getNodeMap().entrySet().size(), "after update merkleTree nodes should be 1");        merkleTreeDao.delete(merkleTree).block();    }    @Test    public void updateBlockchainHeaderTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        String currentHashStr = BinaryHexConverter.bytesToHex(currentHash);        BlockChainMetadata.setBlockChainHash(currentHash);        BlockChainMetadata.setActiveBlock(new AtomicLong(21L));        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(8L));        byte[] updateHash0 = SerializationUtils.serialize(BuildElectionTransaction.build());        byte[] updateHash = SerializationUtils.serialize(updateHash0);        String updateHashStr = BinaryHexConverter.bytesToHex(updateHash);        MerkleTree merkleTree = BuildMerkleTree.build(BlockChainMetadata.getActiveBlock().get(),                                                BlockChainMetadata.getActiveBlockTxCount().get()-1L,                                                updateHash);        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                                                        BlockChainMetadata.getActiveBlockTxCount().get()-1L,                                                                currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        VotingTxBlock vtbBefore = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();        assertEquals(BlockChainMetadata.getActiveBlock().get(), vtbBefore.getBlockId());        assertEquals(votingTxBlock.getVotingBlockHeader().getDateTime(), vtbBefore.getVotingBlockHeader().getDateTime());        assertEquals(currentHashStr, BinaryHexConverter.bytesToHex(vtbBefore.getVotingBlockHeader().getMerkleRoot()), "before Merkle root");        blockChainService.updateTxBlockHeader(merkleTree).block();        VotingTxBlock vtbAfter = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();        assertEquals(BlockChainMetadata.getActiveBlock().get(), vtbAfter.getBlockId());        assert vtbAfter != null;        assertEquals(updateHashStr,                     BinaryHexConverter.bytesToHex(vtbAfter.getVotingBlockHeader().getMerkleRoot()), "after merkle root");        votingTxBlockDao.delete(vtbAfter).block();    }    @Test    public void voterBlockChainProcessTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        String currentHashStr = BinaryHexConverter.bytesToHex(currentHash);        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        blockChainService.setvToken(appendEntry.getvToken());        log.debug("ElectionRequest vToken: "+blockChainService.getvToken().toString());        BlockChainMetadata.setBlockChainHash(currentHash);        BlockChainMetadata.setActiveBlock(new AtomicLong(21L));        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(7L));        MerkleTree merkleTree = BuildMerkleTree.build(BlockChainMetadata.getActiveBlock().get(),                                                      BlockChainMetadata.getActiveBlockTxCount().get(),                                                      currentHash);        MerkleTree insertedMerkleTree = merkleTreeDao.save(merkleTree).block();        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                                                                BlockChainMetadata.getActiveBlockTxCount().get(),                                                                currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        VotingTxBlock votingTxBlockResult = null;        VoterTokenBlockMap vtbmResult = null;        MerkleTree merkleTreeResult = null;        try {            blockChainService.voterBlockChainProcess(appendEntry).block();            votingTxBlockResult = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assert votingTxBlockResult != null;            assertEquals(BlockChainMetadata.getActiveBlockTxCount().get(), votingTxBlockResult.getVotingBlockHeader().getTxCount());            vtbmResult = voterTokenBlockMapDao.findById(electionRequest.getVoter().getVtoken()).block();            assert vtbmResult != null;            assertEquals(BlockChainMetadata.getActiveBlock().get(), vtbmResult.getBlockId());            merkleTreeResult = merkleTreeDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assert merkleTreeResult != null;            assertEquals(BlockChainMetadata.getActiveBlockTxCount().get(), merkleTreeResult.getTxCount());        } catch(Exception ex) {            ex.printStackTrace();        } finally {            merkleTreeDao.delete(merkleTreeResult).block();            votingTxBlockDao.delete(votingTxBlockResult).block();            voterTokenBlockMapDao.delete(vtbmResult).block();        }    }    @Test    public void extendBallotBlockchainTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                                                               BlockChainMetadata.getActiveBlockTxCount().get(),                                                               currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);        blockChainService.followerCommitEntryResponse(appendEntry);        VotingTxBlock votingTxBlockAfter = null;        try {            blockChainService.extendBallotBlockchain(appendEntry).block();            votingTxBlockAfter = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assertEquals((long) votingTxBlockAfter.getVotingBlockHeader().getTxCount(), BlockChainMetadata.getActiveBlockTxCount().get());            log.debug("After BlockId: " + BlockChainMetadata.getActiveBlock().get() + ", TxCount: " + BlockChainMetadata.getActiveBlockTxCount().get());        } catch(Exception ex) {            ex.printStackTrace();        } finally {            votingTxBlockDao.delete(votingTxBlockAfter).block();        }    }    @Test    public void extendBallotBlockchainNullTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);        blockChainService.followerCommitEntryResponse(appendEntry);        VotingTxBlock votingTxBlockAfter = null;        try {            blockChainService.extendBallotBlockchain(appendEntry).block();            votingTxBlockAfter = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assertEquals((long) votingTxBlockAfter.getVotingBlockHeader().getTxCount(), BlockChainMetadata.getActiveBlockTxCount().get());            assertEquals((long) votingTxBlockAfter.getBlockId(), BlockChainMetadata.getActiveBlock().get());            log.debug("After BlockId: " + BlockChainMetadata.getActiveBlock().get() + ", TxCount: " + BlockChainMetadata.getActiveBlockTxCount().get());        } catch(Exception ex) {            ex.printStackTrace();        } finally {            votingTxBlockDao.delete(votingTxBlockAfter).block();        }    }    @Test    public void extendBallotBlockchainTxCountEqualsEightTest() {        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(8L));        log.debug("Before BlockId: " + BlockChainMetadata.getActiveBlock() + ", TxCount: " + BlockChainMetadata.getActiveBlockTxCount());        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        Mockito.doReturn(Mono.just(appendEntry)).when(blockChainService).voterBlockChainProcess(appendEntry);        blockChainService.followerCommitEntryResponse(appendEntry);        VotingTxBlock votingTxBlockAfter = null;        try {            blockChainService.extendBallotBlockchain(appendEntry).block();            votingTxBlockAfter = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assertEquals((long) votingTxBlockAfter.getVotingBlockHeader().getTxCount(), BlockChainMetadata.getActiveBlockTxCount().get());            assertEquals((long) votingTxBlockAfter.getBlockId(), BlockChainMetadata.getActiveBlock().get());            log.debug("After BlockId: " + BlockChainMetadata.getActiveBlock() + ", TxCount: " + BlockChainMetadata.getActiveBlockTxCount());        } catch (Exception ex) {            ex.printStackTrace();        } finally {            votingTxBlockDao.delete(votingTxBlockAfter).block();        }    }    @Test    public void followerCommitEntryResponseTest() {        byte[] currentHash = SerializationUtils.serialize(BuildElectionTransaction.build());        String currentHashStr = BinaryHexConverter.bytesToHex(currentHash);        ElectionRequest electionRequest = BuildElectionRequest.build();        AppendEntry appendEntry = new AppendEntry(ConsensusServer.getServerInstance(),                BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                electionRequest.getElectionTransaction());        appendEntry.setvToken(electionRequest.getVoter().getVtoken());        appendEntry.setCommitted(false);        BlockChainMetadata.setBlockChainHash(currentHash);        BlockChainMetadata.setActiveBlock(new AtomicLong(21L));        BlockChainMetadata.setActiveBlockTxCount(new AtomicLong(7L));        MerkleTree merkleTree = BuildMerkleTree.build(BlockChainMetadata.getActiveBlock().get(),                                                      BlockChainMetadata.getActiveBlockTxCount().get(),                                                      currentHash);        MerkleTree insertedMerkleTree = merkleTreeDao.save(merkleTree).block();        VotingTxBlock votingTxBlock = BuildVotingTxBlock.build(BlockChainMetadata.getActiveBlock().get(),                BlockChainMetadata.getActiveBlockTxCount().get(),                currentHash);        votingTxBlockDao.insert(votingTxBlock).block();        VotingTxBlock votingTxBlockResult = null;        VoterTokenBlockMap vtbmResult = null;        MerkleTree merkleTreeResult = null;        try {            AppendEntry appendEntryResult = blockChainService.followerCommitEntryResponse(appendEntry).block();            assertEquals(Boolean.TRUE, appendEntryResult.getCommitted());            assertEquals(BlockChainMetadata.getBlockChainHash(), appendEntry.getBlockChainHash());            assertEquals(BlockChainMetadata.getBlockChainHash(), appendEntryResult.getBlockChainHash());            log.debug("followerCommitEntryResponseTest: "+appendEntryResult.toString());            votingTxBlockResult = votingTxBlockDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assert votingTxBlockResult != null;            assertEquals(BlockChainMetadata.getActiveBlockTxCount().get(), votingTxBlockResult.getVotingBlockHeader().getTxCount());            vtbmResult = voterTokenBlockMapDao.findById(electionRequest.getVoter().getVtoken()).block();            assert vtbmResult != null;            assertEquals(BlockChainMetadata.getActiveBlock().get(), vtbmResult.getBlockId());            merkleTreeResult = merkleTreeDao.findByBlockId(BlockChainMetadata.getActiveBlock().get()).block();            assert merkleTreeResult != null;            assertEquals(BlockChainMetadata.getActiveBlockTxCount().get(), merkleTreeResult.getTxCount());        } catch(Exception ex) {            ex.printStackTrace();        } finally {            if (merkleTreeResult!=null)                merkleTreeDao.delete(merkleTreeResult).block();            if(votingTxBlockResult!=null)                votingTxBlockDao.delete(votingTxBlockResult).block();            if(vtbmResult!=null)                voterTokenBlockMapDao.delete(vtbmResult).block();        }    }}